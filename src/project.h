// Copyright 2017 Lybros.

/* The project structure is:
 * project_name_folder
 * |--"project-config"
 *
 * More about the structure in io/ directory.
 */

#ifndef SRC_PROJECT_H_
#define SRC_PROJECT_H_

#include <iostream>
#include <string>
#include <vector>
#include <unordered_map>

#include <QDir>
#include <QMap>
#include <QSet>
#include <QString>
#include <QTextStream>

#include <theia/theia.h>
#include <theia/matching/distance.h>
#include <theia/matching/image_pair_match.h>
#include <theia/sfm/camera/camera.h>

#include "io/projectio.h"
#include "featuresx.h"
#include "options.h"
#include "reconstructor.h"
#include "storage.h"

const QString CONFIG_FILE_NAME = "project-config";
const QString DEFAULT_OUTPUT_LOCATION_POSTFIX = "out/";
const QString DEFAULT_MODEL_BINARY_FILENAME = "model-0.binary";

struct Observation {
  Observation(int pId, std::string filename, int x, int y) : worldPointId(pId), filename(filename), x(x), y(y) {}

  int worldPointId;
  std::string filename;
  int x, y;
};

class Project {
  friend class ProjectIO;

 public:
  // This constructor must be called if we're opening an existent project.
  // The Project::ReadConfigurationFile() is called.
  explicit Project(QString project_path);

  // This constructor must be called if we're creating new project. That will
  // create a new project folder in filesystem and call
  // Project::WriteConfigurationFile() method.
  Project(QString project_name, QString project_parent_path,
          QString images_name, QString output_path = QString());

  // Runs Smart building process, which figures out if we need matching stage
  // or it has been already run.
  void BuildModelToBinary();

  void ExtractFeatures();

  void MatchFeatures();

  // To run reconstruction assuming the features are already extracted and
  // matched.
  void StartReconstruction();

  // Try to find place for image on 3d reconstruction map
  QSet<theia::TrackId>* SearchImage(QString file_path, Reconstruction* model);

  QString GetProjectName();

  QString GetProjectPath();

  QString GetImagesPath();

  void SetProjectName(QString);

  void SetProjectPath(QString);

  void SetImagesPath(QString);

  bool WriteConfigurationFile();

  bool ReadConfigurationFile();

  bool ReadSlamData();

  QString GetDefaultOutputPath();

  Storage* GetStorage();

  Options* GetOptions();

  ~Project();

  void Load_SLAM_data();
  // The method reads data generated by some SLAM engine and runs reconstruction
  // process.
  // TODO(uladbohdan): to rename once there's an understanding what are we
  // doing here.
  void SLAM_Build();

  void SLAM_New_Build();

  std::unordered_map<int, theia::ImagePairMatch>& GetSlamData() {
    return slam_data_;
  }

  std::vector<theia::Camera>& GetSLAMCameras() {
    return slam_cameras_;
  }

  std::unordered_map<std::string, theia::Camera>& GetCamerasMap() {
    return slam_cameras_map_;
  }

  std::unordered_map<int, std::vector<Observation>> GetSlamObservations() {
    return slam_observations_;
  }

 private:
  Options* options_;

  QString project_name_;
  // project_path_ contains the full way to the project.
  // e.g. CONFIG_FILE_NAME is directly inside this folder.
  QString project_path_;
  // images_path_ and reconstructions_ is stored inside of Storage object.
  Storage* storage_;
  Features* features_;

  QString GetConfigurationFilePath();

  // TODO(uladbohdan): to consider moving it somewhere else.
  //
  // The key is a two ORB_SLAM2 timestamps merged. ImagePairMatch gathers all
  // the data about these two images combination.
  std::unordered_map<int, theia::ImagePairMatch> slam_data_;

  std::vector<theia::Camera> slam_cameras_;
  std::unordered_map<std::string, theia::Camera> slam_cameras_map_;
  QVector<QString> slam_camera_names_;

  // This is to push observations into reconstruction.
  // Maps PointId to <ImageName, x, y>.
  std::unordered_map<int, std::vector<Observation>> slam_observations_;
};

#endif  // SRC_PROJECT_H_
